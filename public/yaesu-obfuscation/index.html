<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
<title>Reverse Engineering Yaesu FT-70D Firmware Obfuscation | lander&#x27;s posts</title>



<meta property="og:title" content="Reverse Engineering Yaesu FT-70D Firmware Obfuscation">



<meta name="author" content="@landaire">


<meta property="og:locale" content="en-US">


<meta name="description" content="nothing interesting">
<meta property="og:description" content="nothing interesting">



<link rel="canonical" href="https://landaire.net/yaesu-obfuscation/">
<meta property="og:url" content="https://landaire.net/yaesu-obfuscation/">



<meta property="og:site_name" content="lander&#x27;s posts" />





  <meta property="og:type" content="article" />
  <meta property="article:published_time" content="2021-12-27T00:00:00+00:00">



  <link rel="prev" href="https://landaire.net/apple-imageio-dos/">





  <meta name="twitter:card" content="summary">



  <meta property="twitter:title" content="Reverse Engineering Yaesu FT-70D Firmware Obfuscation">








<script type="application/ld+json">
{
  "author": {
    "@type":"Person",
	  "name":"@landaire",
  },
  "description": "nothing interesting",
  "url": "https://landaire.net/yaesu-obfuscation/",
  "@context":"https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reverse Engineering Yaesu FT-70D Firmware Obfuscation"
  
    
    
      "datePublished":"2021-12-27T00:00:00+00:00",
    
    "mainEntityOfPage":{
      "@type":"WebPage",
      "@id":"https://landaire.net/yaesu-obfuscation/"
    },
  
}
</script>

  <link rel="stylesheet" href="https://landaire.net/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <link rel="icon" type="image/png" sizes="32x32" href="https://landaire.net/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://landaire.net/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://landaire.net/assets/apple-touch-icon.png">

  

  

  
  
</head>

<body>
  
  <nav class="nav">
    <div class="nav-container">
      <a href="https://landaire.net">
        <h2 class="nav-title">lander&#x27;s posts</h2>
      </a>
      <ul>
        
          
            <li><a href="https://landaire.net"></a></li>
          
        
      </ul>
    </div>
  </nav>
  

  <main>
    
  <div class="post">
  	<div class="post-info">
  		<span>Written by</span> @landaire<br>
  		<span>on&nbsp;</span><time datetime="2021-12-27">December 27, 2021</time>
  	</div>
  	<h1 class="post-title">Reverse Engineering Yaesu FT-70D Firmware Obfuscation</h1>
  	<div class="post-line"></div>
  	<p><em>Click on any of the images to view at its original resolution.</em></p>
<h2 id="background">Background</h2>
<p>Ham radios are a fun way of learning how the radio spectrum works, and more importantly: they're embedded devices that may run weird chips/firmware! Sometime last week I got curious how easy it'd be to hack my Yaesu FT-70D, so I started doing some research. The only resource I could find for Yaesu radios was <a href="https://www.reddit.com/r/amateurradio/comments/cwoxvv/yaesu_ft1dr_custom_firmware/">someone who posted about custom firmware for their Yaesu FT1DR</a>.</p>
<p>The Reddit poster mentioned that if you go through the firmware update process via USB, the radio exposes its Renesas H8SX microcontroller and can have its flash modified using the Renesas SDK. This was a great start and looked promising, but the SDK wasn't trivial to configure and use to dump the firmware, so I didn't use it for very long.</p>
<h2 id="initial-recon">Initial Recon</h2>
<p>Yaesu provides a firmware updater in the form of a Windows application on their website:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;firmware_page.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;25f987adea9dbac600.png" /></a>
<p>The zip contains the following files:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>1.2 MB  Wed Nov  8 14:34:38 2017  FT-70D_ver111(USA).exe
</span><span>682 KB  Tue Nov 14 00:00:00 2017  FT-70DR_DE_Firmware_Update_Information_ENG_1711-B.pdf
</span><span>8 MB  Mon Apr 23 00:00:00 2018  FT-70DR_DE_MAIN_Firmware_Ver_Up_Manual_ENG_1804-B.pdf
</span><span>3.2 MB  Fri Jan  6 17:54:44 2012  HMSEUSBDRIVER.exe
</span><span>160 KB  Sat Sep 17 15:14:16 2011  RComms.dll
</span><span>61 KB  Tue Oct 23 17:02:08 2012  RFP_USB_VB.dll
</span><span>1.7 MB  Fri Mar 29 11:54:02 2013  vcredist_x86.exe
</span></code></pre>
<p>I'm going to assume that the file specific to the FT-70D, &quot;FT-70D_ver111(USA).exe&quot;, will likely contain our firmware image. An EXE file can contain binary resources in the <code>.rsrc</code> section -- let's see what this binary contains using <a href="https://github.com/horsicq/XPEViewer">XPEViewer</a>:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;exe_resources.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;ef5037281b2f00c800.png" /></a>
<p>Resources fit into one of many different <a href="https://docs.microsoft.com/en-us/windows/win32/menurc/resource-types">resource types</a>, but a firmware image would likely be put into a custom type. What's this last entry, &quot;23&quot;? Expanding that node we have a couple of interesting items:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;start_update.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;9b644680a3f644ba00.png" /></a>
<p><code>RES_START_DIALOG</code> is a custom string the updater shows when preparing to start an update, so we're in the right area!</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;res_update_info.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;5f50d20e1743f88e00.png" /></a>
<p><code>RES_UPDATE_INFO</code> looks like just binary data -- perhaps this is our firmware image? Unfortunately looking at the Strings tab or running the <code>strings</code> utility over this data yields nonsensical data... so this firmware image is likely encrypted.</p>
<h2 id="reverse-engineering-the-binary">Reverse Engineering the Binary</h2>
<p>We know the firmware image is encrypted, but we need to figure out <em>how</em>. A good starting point is the the string we saw above, <code>RES_UPDATE_INFO</code>. Windows applications load resources by calling one of the <a href="https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-findresourcea"><code>FindResource*</code> APIs</a>. <code>FindResourceA</code> has the following parameters:</p>
<ol>
<li><code>HMODULE</code>, a handle to the module to look for the resource in.</li>
<li><code>lpName</code>, the resource name.</li>
<li><code>lpType</code>, the reosurce type.</li>
</ol>
<p>If we load the binary into a disassembler and look for references to the <code>RES_UPDATE_INFO</code> string, we could likely find calls to <code>FindResourceA</code> with this string as an argument in the <code>lpName</code> position.</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;update_info_xrefs.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;2625d40b24a2764900.png" /></a>
<p>We find a match in a function which happens to find/load <em>all</em> of these custom resources under type <code>23</code>.</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;load_resource_decompiler_output.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;e7ce598bcab2083000.png" /></a>
<p>There's a few ways we can see how this data is used, but I often find that there may be a lot of steps between when data is loaded and when it's used. To speed things up we're going to use a debugger's assistance. I used WinDbg's <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/time-travel-debugging-overview">Time Travel Debugging</a> to record an execution trace of the updater while it updates my radio. TTD is an invaluable tool as we'll find out later.</p>
<p>We can see via the decompiler output that this function copies the <code>RES_UPDATE_INFO</code> resource to a dynamically allocated buffer (note: the <code>qmemcpy()</code> is inlined and represented by a <code>rep movsd</code> instruction in the disassembly). So we need to break at the <code>movsd</code> instruction, and examine the <code>edi</code> register's (destination address) value. It's <code>0x2be5020</code>, and we can now set a memory access breakpoint by entering <code>ba r4 0x2be5020</code> in the command Window to see where this data is used next.</p>
<p>Our breakpoint is hit at <code>0x4047DC</code> -- back to the disassembler. In IDA you can press <code>G</code> to go to an address. We're finally at the data processing function:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;deobfuscate_function.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;acdc8642e8d4225e00.png" /></a>
<p>It looks like the first 4 bytes of our data is used as a time value and formatted as a string with <code>%Y%m%d%H%M%S</code>. With this knowledge let's clean up the variables:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;cleaned_up_deobfuscate.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;65811fbd035a895800.png" /></a>
<p>The timestamp is passed to <code>sub_4082c0</code>, but what about the rest of the data? We can see here that it's used in <code>sub_408350</code> on line 19. Based on how it's called, I'd wager its signature is something like:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span>status_t </span><span style="color:#8fa1b3;">decrypt_data</span><span>(uint8_t *</span><span style="color:#bf616a;">input</span><span>, size_t </span><span style="color:#bf616a;">input_len</span><span>, uint8_t *</span><span style="color:#bf616a;">output</span><span>, </span><span style="color:#bf616a;">output_len</span><span>, size_t *</span><span style="color:#bf616a;">out_data_processed</span><span>);
</span></code></pre>
<p>Let's see what it does:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;deobfuscate_data.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;37b7a8ca123f00e100.png" /></a>
<p>I think we've found our function that starts decrypting the firmware. To confirm, let's set a breakpoint in our debugger at the function callee address <code>0x404842</code> so we can examine the contents of the <code>output</code> parameter before and after the function is called.</p>
<p>Here's the data before the function call:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;data_before.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;08d4fbea026a7dd700.png" /></a>
<p>After stepping over the function call:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;data_after.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;f2c9ba709eb9a42000.png" /></a>
<p>We can dump this data to a file using the following command:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>.writemem C:\users\lander\documents\maybe_deobfuscated.bin 0x2d7507c L100000
</span></code></pre>
<p>010 Editor has a built-in strings utility (Search &gt; Find Strings...) and if we scroll down a bit in the results, we have real strings that appear in my radio!</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;hex_editor_strings.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;d3d69d7f63b9d3f200.png" /></a>
<p>At this point if we were just interested in getting the plaintext firmware we could stop messing with the binary and <a href="https://landaire.net/yaesu-obfuscation/#loading-the-firmware-in-ida-pro">load the firmware into IDA Pro</a>... but I want to know how this obfuscation works.</p>
<h2 id="obfuscation-details">Obfuscation Details</h2>
<p>Just to recap from the last section:</p>
<ul>
<li>We've identified our data processing routine (let's call this function <code>perform_deobfuscation</code>).</li>
<li>We know that the first 4 bytes of the update info are a Unix timestamp that's formatted as a string and used for an unknown purpose.</li>
<li>We know which function decrypts our firmware image.</li>
</ul>
<h3 id="data-decryption">Data Decryption</h3>
<p>Let's look at the firmware image decryption routine with some renamed variables:</p>
<p><strong>INSERT IMAGE</strong></p>
<p>At a high level this routine:</p>
<ol>
<li>Allocates a 64-byte scratch buffer</li>
<li>Checks if there's any data to process. If not, set the output variable <code>out_data_processed</code> to the number of bytes processed and return 0x0 (<code>STATUS_SUCCESS</code>)</li>
<li>Loop over the input data in 8-byte chunks and inflate each byte to its bit representation.</li>
<li>After the 8-byte chunk is inflated, call <code>sub_407980</code> with the scratch buffer and <code>0</code> as arguments.</li>
<li>Loop over the scratch buffer and reassemble 8 sequential bits as 1 byte, then set the byte at the appropriate index in the output buffer.</li>
</ol>
<p>Lots going on here, but let's take a look at step #3. If we take the bytes <code>0xAA</code> and <code>0x77</code> which have bit representations of <code>0b1010_1010</code> and <code>0b0111_1111</code> respectively and inflate them according to the decompiler output, we end up with:</p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |    | 8 | 9 | A | B | C | D | E | F |
</span><span>|---|---|---|---|---|---|---|---|----|---|---|---|---|---|---|---|---|
</span><span>| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |    | 0 | 1 | 1 | 1 | 0 | 1 | 1 | 1 |
</span></code></pre>
<p>This routine does this process over 8 bytes at a time, completely filling the 64-byte scratch buffer with 1s and 0s just like the table above.</p>
<p>Now let's look at step #4 and see what's going on in <code>sub_407980</code>:</p>
<p><strong>INSERT IMAGE</strong></p>
<p>Oof. This is more complicated. We can see what may be an immediate roadblock: this function takes in a C++ <code>this</code> pointer and uses data from it while performing bitwise operations. For now let's call this our &quot;key&quot; and come back to its later.</p>
<h3 id="key-setup">&quot;Key&quot; Setup</h3>
<p>We now need to figure out how our <code>key</code> is set up for usage in the <code>swap_bytes</code> function above. My approach here is to set a breakpoint at the first instruction to use this data in <code>swap_bytes</code>, which happens to be <code>lea ecx, [ecx+ecx*2]</code> at 0x004079cb.</p>
<p>We hit the breakpoint and can calculate the address of the data as <code>FIXFIXINSERTPOINTER</code> <strong>FIXME</strong>. We can now lean on TTD to help us figure out where this data was last written. Let's set a memory write breakpoint at this address using <code>ba w4 &lt;FIXFIXINSERTPOINTER&gt;</code> <strong>FIXME</strong> and press the <code>Step Out Back</code> button. If you've never used TTD before, this operates exactly as <code>Step Out</code> would except <em>backwards</em> in the program's trace. If we hit this once, we will break at the <code>call</code> instruction for the current function. Let's keep pressing it until we see that our breakpoint was hit.</p>
<p>Our memory write breakpoint gets triggered at <code>ba w4 &lt;INSERT&gt;</code> <strong>FIXME</strong> -- a function we haven't seen before. The callstack shows that it's called not terribly far from our <code>perform_deobfuscation</code> routine!</p>
<ul>
<li><code>set_key</code> (we are here -- function is originally called <code>sub_407850</code>)</li>
<li><code>sub_4082c0</code></li>
<li><code>perform_deobfuscation</code></li>
</ul>

<a href="&#x2F;img&#x2F;yaesu&#x2F;timestamp_inflation.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;b05aab5cc23b52da00.png" /></a>
<p>Not a lot to see here except the same function called 4 times, initially with the timestamp string as an argument in position 0, a pointer to 64-byte buffer, and each subsequent function call using the return value of the last. The function our debugger just broke into takes only 1 argument, which is the 64-byte buffer used across <em>all</em> of these function calls. So what's going on in <code>sub_407e80</code>?</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;inflate_timestamp.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;3c575f1a77f1e7c500.png" /></a>
<p>The bitwise operations that look supsiciously similar to the byte to bit inflation we saw above. After renaming things and performing some loop unrolling, the function looks like this:</p>
<pre data-lang="c" style="background-color:#2b303b;color:#c0c5ce;" class="language-c "><code class="language-c" data-lang="c"><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">inflate_timestamp</span><span>(</span><span style="color:#b48ead;">char </span><span>*</span><span style="color:#bf616a;">timestamp_str</span><span>, </span><span style="color:#b48ead;">char </span><span>*</span><span style="color:#bf616a;">output</span><span>, uint8_t *</span><span style="color:#bf616a;">unknown_data</span><span>) {
</span><span>    </span><span style="color:#b48ead;">for </span><span>(size_t output_idx = </span><span style="color:#d08770;">0</span><span>; output_idx &lt; </span><span style="color:#d08770;">8</span><span>; output_idx++) {
</span><span>        uint8_t ts_byte = *timestamp_str;
</span><span>        </span><span style="color:#b48ead;">if </span><span>(ts_byte) {
</span><span>            timestamp_str += </span><span style="color:#d08770;">1</span><span>;
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> bit_idx = </span><span style="color:#d08770;">7</span><span>; bit_idx &gt; </span><span style="color:#d08770;">0</span><span>; bit_idx--) {
</span><span>            uint8_t bit_value = (ts_byte &gt;&gt; (</span><span style="color:#d08770;">7 </span><span>- bit_idx)) &amp; </span><span style="color:#d08770;">1</span><span>;
</span><span>            output[(output_idx * </span><span style="color:#d08770;">8</span><span>) + bit_idx] ^= bit_value;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#bf616a;">set_key</span><span>(this, unknown_data);
</span><span>    </span><span style="color:#bf616a;">perform_bit_swap</span><span>(this, output, </span><span style="color:#d08770;">1</span><span>);
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> timestamp_str;
</span><span>}
</span></code></pre>
<h2 id="loading-the-firmware-in-ida-pro">Loading the Firmware in IDA Pro</h2>
<p>IDA thankfully supports disassembling the Hitachi/Rensas H8SX architecture. If we load our firmware into IDA and select the &quot;Hitachi H8SX advanced&quot; processsor type, use the default options for the &quot;Disassembly memory organization&quot; dialog, then finally choose &quot;H8S/2215R&quot; in the &quot;Choose the device name&quot; dialog...:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;rom_initial_load.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;933e16fa82cfe1ed00.png" /></a>
<p>We don't have shit. I'm not an embedded systems expert, but my friend Will suggested that the first few DWORDs look like they may belong to a vector table. If we right-click address 0 and select &quot;Double word 0x142A&quot;, we can click on the new variable <code>unk_142A</code> to go to its location. Press <code>C</code> at this location to define it as Code, then press <code>P</code> to create a function at this address:</p>

<a href="&#x2F;img&#x2F;yaesu&#x2F;firmware_analyzed.png"><img src="https:&#x2F;&#x2F;landaire.net&#x2F;processed_images&#x2F;ceb0cbe76897e99c00.png" /></a>
<p>We can now reverse engineer our firmware :)</p>

  </div>

	

  <div class="pagination">
  	
		<a href="#" class="top">Top</a>
		<a href="https://landaire.net/apple-imageio-dos/" class="right arrow">&#8594;</a>
  </div>

  </main>

  
  <footer>
    <span>&copy; 2021 Aaran Xu. Made with <a href="https://www.getzola.org">Zola</a> using the <a
          href="https://github.com/aaranxu/tale-zola">Tale-Zola</a> theme.</span>
  </footer>
  
</body>
</html>
